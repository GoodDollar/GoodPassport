/**
0x57c8fafcc8b262f2a9aac3069057f1e19198cbf800414242e907532bcde25ed13a8aa824b5dac1d482c7a33d44348ba0ed176e1e7e8e49176d45a778c6c2c3f80c2e41e9423b6ae817fbe7b469dce32602cc9e3a36aa3f2f7353983aac89c513aa796c1b3c28701fb1cbc96b56bc5174aab54ee739dc31012fb8c66ffe9aa07d74534a361ebc8119004c4ad9508d18d32143c22fae22c984c99dfb1c595f1caacaf9c9653aff0d885e324c6333b370f307b1d34af4cd661651d752c64cbc98027a4cc1e84577c352013d75c70728750abbc8fa7fbc1ceb4e824131a709d6d9871b1caf8b6fdde06ae68d2d9783f23455a9aa0919f93ec5ef142eae5561ec845c580d113d84e9fe7d6d5dd45a1ff43e309e57b773069f462d683c8ee0c61ea44c3c367908f3d2b9caf3d8a1d2e773f354456df112ad06b47703fa889d7cf46be21b44d57ba2ea7670a0c7ab2be92e6af99ee6b1260fe360eb41dec944a4524c130c54ed24922d93c40ca4292a7f88faec72b385fb961c7a7a549bf98a20fe14791edc2f9e4f7cff6dfdfe1df10ffa51993d957f636f6ca189acc8c6c0185e4aa71d93612b07c33f6c0ffad9714d15d42ebeea48a8d560b19b8f2406a769248ed07e5d84105edcdffebca6a9a5931720816898e9374cabf3d5038999f5fc05cff6cf2526b51bd78943d29526e89c0f9f3446cf25346df36d4827f0616b48ecf55ecd2eb0837c9b4c962c22d2ff8b5441b7b45805887f051d39bf133b583baf6860869c20a7d0adb3234b2cf62c536ba40fd2ef76dd486aeb0df6bd36c336487a40000000000000000000000000000000000000000000000000000000000000000
0x57c8fafcc8b262f2a9aac3069057f1e19198cbf800414242e907532bcde25ed13a8aa824b5dac1d482c7a33d44348ba0ed176e1e7e8e49176d45a778c6c2c3f80c2e41e9423b6ae817fbe7b469dce32602cc9e3a36aa3f2f7353983aac89c513aa796c1b3c28701fb1cbc96b56bc5174aab54ee739dc31012fb8c66ffe9aa07d74534a361ebc8119004c4ad9508d18d32143c22fae22c984c99dfb1c595f1caacaf9c9653aff0d885e324c6333b370f307b1d34af4cd661651d752c64cbc98027a4cc1e84577c352013d75c70728750abbc8fa7fbc1ceb4e824131a709d6d9871b1caf8b6fdde06ae68d2d9783f23455a9aa0919f93ec5ef142eae5561ec845c580d113d84e9fe7d6d5dd45a1ff43e309e57b773069f462d683c8ee0c61ea44c3c367908f3d2b9caf3d8a1d2e773f354456df112ad06b47703fa889d7cf46be21b44d57ba2ea7670a0c7ab2be92e6af99ee6b1260fe360eb41dec944a4524c130c54ed24922d93c40ca4292a7f88faec72b385fb961c7a7a549bf98a20fe14791edc2f9e4f7cff6dfdfe1df10ffa51993d957f636f6ca189acc8c6c0185e4aa71d93612b07c33f6c0ffad9714d15d42ebeea48a8d560b19b8f2406a769248ed07e5d84105edcdffebca6a9a5931720816898e9374cabf3d5038999f5fc05cff6cf2526b51bd78943d29526e89c0f9f3446cf25346df36d4827f0616b48ecf55ecd2eb0837c9b4c962c22d2ff8b5441b7b45805887f051d39bf133b583baf6860869c20a7d0adb3234b2cf62c536ba40fd2ef76dd486aeb0df6bd36c336487a400000000000000000000000005ef842ce
 v.verify("0xcd2eb0837c9b4c962c22d2ff8b5441b7b45805887f051d39bf133b583baf6860869c20a7d0adb3234b2cf62c536ba40fd2ef76dd486aeb0df6bd36c336487a40",65537,"0xc84bc6811256fdb1d7dd1a99e5e611102f5df81ea544c3a091e1f78d4919a4778c1ed8f40c54aa1248a5c29692e2edb1f50c6afcee8933670bf155683f65d44d","0x0001ffffffffffffffffffff003031300d060960864801650304020105000420cd2eb0837c9b4c962c22d2ff8b5441b7b45805887f051d39bf133b583baf6860","0x143a352eb48b73bfc91759f4c63ac19670bf01ff0e1305e3e6bb67cb3dcaa94e2a0a8f73c11394d1404d4a4646d2984e45c103f62d4d7b810816e947dd6ad9ce",["0x62f3c8d44f779f029118dc3f878f1c084b870c189da2a2db7ddcbec8ffe525e178dfd2d5ac5deb55c5131f39ba810366e5bfb1d3cc016c3a21d49fada671128f","0x106691a12dda358ff203b2feec8cfbbada4270d0bf7fdd43913d771a616589c52789c690f358292a3aa99904a3fd359828defdf77281f830dacaa4948b279f92","0x3c1aaafbf5681bc598a3045e97f68315c3229b4bb96a3dd9da3ad4dbf39d9062345bdce29bc36183fa1835ec159440d97bb7d3143e26afe4155459713d8bfaec","0xb6582f429f85db1a7342a9d8de7f9747762f704f60abac8d6692e1b9e03ac6f0a77c8112e8a25428bf2b9cadcbda79a02fd98fae03ed57875cacfdae7a00b3e8","0x7e341ffe9dbeaa1d4cfc3b8a8c1740cbe3907fd0da183d4ca26151c925f1bf28903b69f2f85e909f0f8e2dbf8c6ba96c9b3ac62b79b8ad51c6cea502f642c4fe","0xa02c3e6ff2b2ec5930a829500da16adc1587c51b447bb3a953a83c6bbb5e2a38364f4679eedfd7bd08de7f21091e60331706ae46e0070aa43da95baca34f40f8","0x756f76287af83cf2c1ff2e29de4da9132137c411e54f3fe96ba4ee446193f2f37d2dd9ebbbd70a6b68f7661a7a241c55afd0222b9caad07ce6301bc7f4854275","0x2128038f3454c6eff5013992177ce496891b8fc9e4037b2f4e4cab85b02b78b5af8df66d8b9d491dc1b885b29d4e552e0c996848c41389d1919b618c37d5c451"],["0x2aa3","0xbda3","0xbedf","0xb06d","0x3899","0xa4b2","0xe4fb","0xcec2"],"0x2aa3bda3bedfb06d3899a4b2e4fbcec25c215a4e9b1a81c91356d4876f7347cc")
 */

pragma solidity >=0.4.21 <0.7.0;
pragma experimental ABIEncoderV2;

import "./BigNumber.sol";
import "./SHA1.sol";

/*
"0xcd2eb0837c9b4c962c22d2ff8b5441b7b45805887f051d39bf133b583baf6860869c20a7d0adb3234b2cf62c536ba40fd2ef76dd486aeb0df6bd36c336487a40","65537","0xB1428D956B139A092ABE6C7C8D56A069A48E85F26ED707547A5CFB03FEFE4509F22B52B5384CEFB05EAE8FFB953FCB829A730C4B2231DADA2BA230F541AC716D","0x0001ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff003031300d060960864801650304020105000420cd2eb0837c9b4c962c22d2ff8b5441b7b45805887f051d39bf133b583baf6860","0x037f37a7b3512029df841c18cdd7c7fae32bf8fa08129999039199900de16a625e29fdb6f7917a70a8255ea5c5d1d33f3f607ad862cf747db1f9074e52f19bdf",["0x816a1f93c82e7f5d726bdf37c4732fbdbe586ba8a526003508f095ca82aa16c466e794d08d85b443acdaee4346b99bbefc19b6332ad2570fcfd0b937fd33dd3b","0x9f1b2f76408215e1ef42344812b29f43aedb42eb115b059414f1a9debe175229e8f71baa120483af688584cc72c69389b7029dae0cb202ac8ad12dc9a4f19c8b","0x971482b111d867437a4c11bfa2d5f8b69063162c80457105ac4c3a39bec0ebfd87199ca3b4d70f3115e525ae37ef710a97dae3ee5a26fab8e2ce38bf4286a1de","0x12548af077844a1b25410ed59251ffaa4c86ec07941cfb01de5ae705568766c6e167650e20779d1052ea8c3f31a8b207919e0236e2bcf2ceb5212806293353f6","0x551def535d4262dac5a3596deda617bd0edaadffa30e589f613da525256d3a2239416595cf30b5ecea08bfca083ff97885bfe71deb57b4450fd3117142b4ce80","0x1b16ef29c1720009b03d0f31589db681011446075386a7de61ac7f3ce8f760f7cfcc8d8debdb7d6157d5a30b337610e049e1f1c10275ed168ece4d7bdcd4fb01","0xa8e8722e6fe73d7e7672186d8a0a406944a585cfb66d2cb24cae0bc12e164e8b522bbc2fdaa6dc6066c9ece225eeb933f216fb2747f62a33088ff3ed7e8960c7","0x107a7b74028e10361ac73ef133de246c42314eda96f727b19e7c0a6e9f5b2906386f6c26075035f25cbbfceea26af43e86c071d5bdab6da3b57bc8db73376b9c"],["0xd863","0xb307","0x9f51","0xf680","0x8186","0xa3ef","0x57e3","0x11e0"],"0x82f6743e765578a35fe5e29659bdfdeb5edfbca2bd7a40c66f101062e89055d4"
*/
contract GQVerifier {
    using BigNumber for *;
    uint256 SHA1SIZE = 20;
    bytes20 SHA1LABEL = hex"da39a3ee5e6b4b0d3255bfef95601890afd80709";
    uint8[] SHA256PREFIX = [
        0x30,
        0x31,
        0x30,
        0x0d,
        0x06,
        0x09,
        0x60,
        0x86,
        0x48,
        0x01,
        0x65,
        0x03,
        0x04,
        0x02,
        0x01,
        0x05,
        0x00,
        0x04,
        0x20
    ];

    event BN(string name, bytes res, bool neg, uint256 bitlen);

    constructor() public {}

    /**
    v = await GQVerifier.new()
v.verify("0xcd2eb0837c9b4c962c22d2ff8b5441b7b45805887f051d39bf133b583baf6860869c20a7d0adb3234b2cf62c536ba40fd2ef76dd486aeb0df6bd36c336487a40",65537,"0xB1428D956B139A092ABE6C7C8D56A069A48E85F26ED707547A5CFB03FEFE4509F22B52B5384CEFB05EAE8FFB953FCB829A730C4B2231DADA2BA230F541AC716D","0x0001ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff003031300d060960864801650304020105000420cd2eb0837c9b4c962c22d2ff8b5441b7b45805887f051d39bf133b583baf6860","0x037f37a7b3512029df841c18cdd7c7fae32bf8fa08129999039199900de16a625e29fdb6f7917a70a8255ea5c5d1d33f3f607ad862cf747db1f9074e52f19bdf",["0x4893ff08cb709c4396afae7e483093f7cbfdbbd2f0a608332b58b81db4af8d098eeaac8cf9351b08436ffb8b866ab5338f7304d13f4dff32cdaeec5579d1235e","0x551d53cdd273dbc383f3204dd6c2bad61a5cc641bacb0a25473de2c7815bb56c1292661a266e5effd803e8028c97af751124727a98bc25e6db2a3c222533c23b","0x1395cc29cbaacce0ea358b63aff7efd2cb6dad488c71ff3f60ab52ae4f5f250f3696ada5739a0f1c7815a076e60335a92ea07027d098b02789a903a6c37d06a6","0x9338e4c39d9f156c38cc0789636fd2ea6abeb596b03c3e0410843bb2c7bf032912677e070f4409e3fc521ffaf0cced1bd0ef3bddb9db7e8677a5e18e5e3cfa9f","0x2ae0c6fc61229b8f6b82b2f01c9bcb73734be4534245a696bad30e1df7bbab3feb8467d6c3e15a90ae14e791a234f52d6f9676459c3fea1e3ba5877ae77073f","0x370af9ec99a48b1bbac1b464f9ddbd05afc797c0fda73e3edd31ea156eafbca64bde45f807a71b448b163857590abc3d67d39b377a2871a277ae5f5e1310ff9c","0xafdf12becdd47cacc8c834ad36063e9ced2a5adc2ed0eb1c35d6de5822087966a1971973dbf9bee7f41812cd1e67851b851a0dd3c046b8b50a57565a7f847198","0x1186dcc4f69626d2b07921c20f807be8a8b605f8c8bb32e37652c67dfc1ff5f26903222366035ce5f8eebbf4136d372e431362fb395f7f59523f11dec7cf77c2"],["0xa761","0x9308","0x7049","0x8ab9","0xd984","0x19fa","0xc463","0x237e"],"0xa761930870498ab9d98419fac463237ee3a994e560036232c4a8b311adf1eaa8")
res = await v.verify("0x869c20a7d0adb3234b2cf62c536ba40fd2ef76dd486aeb0df6bd36c336487a40",'65537',"0xB1428D956B139A092ABE6C7C8D56A069A48E85F26ED707547A5CFB03FEFE4509F22B52B5384CEFB05EAE8FFB953FCB829A730C4B2231DADA2BA230F541AC716D","0x001FFFFFFFFFFFFFFFFFFFF003031300D060960864801650304020105000420869C20A7D0ADB3234B2CF62C536BA40FD2EF76DD486AEB0DF6BD36C336487A40","0x745842ABE05E241DC6B9CBB48234618BA493296C2E9DF21FB710CD89ACDEC973BF9409BC8FFE017DD1C69679E77699D787D0D4D4FE9B2AB005ADCFBABD4776D0",["0x004F44AEEA14B13E86BCFB92B24DD83B7553E55511F7EBC94C0DA078F77CD858E8DFFE48C0A77EDE43A40F407CB1E7CDD07C3137B1FBF3A878C9C0624DE49BDE","0x22AD520AAAFB464564ED2D95AE553787935091CFB190B3C3515CFBFEDC08C1E32EBCE69E8921293C4E490543202B0C177EAB0B1126CC770A6DA94C6F40C20CF2","0x34844AEA9D8E144F6BADDFAFA47063A26F53226028D8EEAF54C9E532F803CAD187CE9E8F04C9A3EFBCEDE3886770CA395E444DBD3C7779DFFF8F9EE829389E10","0xA7A0990217A5851355D8A392B1EC08D078639D17D1323DFC3C5DF4C3A2AA2058312B7E264F39AA32B7D018FF3AB558950F15327D34BF200A6A8580A1E7B13AF1","0x910C38E26ED7B9A1121B987638989A2F16C9DF6370A5A987BDF0255F0DB5E75A3DFD90BBE42BABAC6119E436665BF7EFE82E1D3839DB0DC6466394BF5623978A","0x6F05B85FC685D45FA476B37F7846C66729B5A469C457589FABFD08213E8AD7AA2E083CED480EF33205112E5247C317E81614A929AA502EB65A104CA09FA740C9","0xA997329F5A3496482EAFDEBA1DB0BEF531519D8C36FAEF8452A3BB3C0DE2541BD271142D5235E63061757650845307D88B254A2947DDD08A833EBD64EE80C786","0x3C37E58A937A286B1ECF46C43B8E943466D824683A91A19DCBF796EF676F1242ECA11A15E21E2FA0B28E38B4231861A99ADD6E7A5458D2FF8D1B83F7496A2F5C"],["0xFCDE","0xFD31","0x3B92","0xC500","0xC98F","0xEB35","0x560E","0xEC5B"])
 */
    /**
     @dev verify a GQ ZK proof of passport signature
     @param unique Array[3] passportHash, publicKey, nonce
    */
    function registerIdentity(
        bytes memory n,
        bytes memory e,
        uint256[] memory ds,
        bytes[] memory ts,
        bytes memory digest,
        bytes memory inverse_digest,
        bytes32 randomOracleHash,
        bytes32[] memory unique,
        bytes memory signedRequest,
        bytes memory pssMask
    ) public returns (bool) {
        // address signer = address(uint160(uint256(unique[1])));
        // uint256 nonce = uint256(unique[2]);
        // require(digest.length == 64, "m must be 512 bits");
        require(now - uint256(unique[2]) < 2 minutes, "invalid nonce");
        require(inverse_digest.length == 64, "inverse_m must be 512 bits");
        require(isKnownSigner(n, e), "invalid certificate signer");
        require(isIdentityNew(unique[0]), "identity already used");
        require(
            n.length == digest.length,
            "digest is not same size as RSA bits"
        );
        require(
            msg.sender == address(uint160(uint256(unique[1]))) ||
                verifySigner(
                    signedRequest,
                    randomOracleHash,
                    address(uint160(uint256(unique[1])))
                ),
            "unauthorized request"
        );
        require(
            verifyRSA(digest, unique[0], n, pssMask),
            "invalid RSA paddings"
        );

        for (uint256 i = 0; i < 8; i++)
            require(ts[i].length == 64, "t must be 512 bits");
        verifyInverseM(digest, n, inverse_digest);

        verifyProof(n, e, ds, ts, inverse_digest, unique, randomOracleHash); //this will revert if proof invalid
        saveIdentity(uint256(unique[0]), address(uint160(uint256(unique[1]))));
        return true;
    }

    function verifyRSA(
        bytes memory digest,
        bytes32 passportHash,
        bytes memory n,
        bytes memory insecureMask
    ) public view returns (bool) {
        return
            verifyPKCS(digest, passportHash) ||
            verifyPSS(digest, passportHash, n.length * 8, insecureMask) == 0;
    }

    function verifyPSS(
        bytes memory digest,
        bytes32 passportHash,
        uint256 nBits,
        bytes memory insecureMask
    ) public view returns (uint256) {
        uint256 emLen = (nBits - 1) / 8;
        if ((nBits - 1) % 8 > 0) emLen += 1;
        if (emLen < SHA1SIZE + 20 + 2) {
            //hash length +  salth length + 2
            return 1;
        }

        uint256 emStart = digest.length - emLen;
        if (digest[emStart + emLen - 1] != 0xbc) {
            return 2;
        }

        //var maskedDB = em.substr(0, maskLen);

        /* 6. If the leftmost 8emLen - emBits bits of the leftmost octet in
         *    maskedDB are not all equal to zero, output "inconsistent" and stop. */
        bytes2 mask2 = (bytes2(0xFF00) >> (8 * emLen - nBits + 1)) & 0x00FF;
        bytes1 mask = bytes1(mask2[1]);
        // bytes1 mask = bytes2(0xFF00 >> (8 * emLen - rsaBits)) & 0xFF;
        if ((digest[emStart] & mask) != 0) {
            return 3;
        }
        uint256 maskLen = emLen - SHA1SIZE - 1;
        bytes memory h = new bytes(SHA1SIZE);
        for (uint256 i = 0; i < SHA1SIZE; i++) {
            h[i] = digest[emStart + maskLen + i];
        }
        /* 7. Let dbMask = MGF(H, emLen - hLen - 1). */
        bytes memory dbMask;
        if (insecureMask.length == maskLen) {
            if (false == pss_verifyMask(h, insecureMask, maskLen)) {
                return 7;
            }
            dbMask = insecureMask;
        } else dbMask = pss_mgf1(h, maskLen);
        /* 8. Let DB = maskedDB \xor dbMask. */
        bytes memory DB = xorBytes(digest, dbMask, emStart, maskLen);
        /* 9. Set the leftmost 8emLen - emBits bits of the leftmost octet
         * in DB to zero. */
        DB[0] = DB[0] & ~mask;
        // /* 10. If the emLen - hLen - sLen - 2 leftmost octets of DB are not zero
        //  * or if the octet at position emLen - hLen - sLen - 1 (the leftmost
        //  * position is "position 1") does not have hexadecimal value 0x01,
        //  * output "inconsistent" and stop. */
        uint256 checkLen = emLen - SHA1SIZE - 20 - 2;
        if (DB[checkLen] != 0x01) {
            return 4;
        }
        for (uint256 i = 0; i < checkLen; i++) {
            if (DB[i] != 0x00) {
                return 5;
            }
        }
        // /* 11. Let salt be the last sLen octets of DB. */
        bytes memory salt = new bytes(20);
        for (uint256 i = 0; i < 20; i++) salt[i] = DB[DB.length - 20 + i];
        // /* 12.  Let M' = (0x)00 00 00 00 00 00 00 00 || mHash || salt */
        bytes memory m = abi.encodePacked(
            bytes8(0),
            bytes20(passportHash),
            salt
        );
        // /* 13. Let H' = Hash(M'), an octet string of length hLen. */
        bytes20 h_ = SHA1.sha1(m);
        // /* 14. If H = H', output "consistent." Otherwise, output "inconsistent." */
        for (uint256 i = 0; i < 20; i++) if (h[i] != h_[i]) return 6;
        return 0;
    }

    /**
     * @dev calculating mgf1 sha1 hashes is expensive in gas.
     * this version receive precalculated mask and verifies the first and last hashes of mask
     */
    function verifyPSS_Cheap_insecure(
        bytes memory digest,
        bytes32 passportHash,
        uint256 nBits,
        bytes memory insecureMask
    ) public view returns (uint256) {
        uint256 emLen = (nBits - 1) / 8;
        if ((nBits - 1) % 8 > 0) emLen += 1;
        if (emLen < SHA1SIZE + 20 + 2) {
            //hash length +  salth length + 2
            // return 1;
        }

        uint256 emStart = digest.length - emLen;
        if (digest[emStart + emLen - 1] != 0xbc) {
            // return 2;
        }

        //var maskedDB = em.substr(0, maskLen);

        /* 6. If the leftmost 8emLen - emBits bits of the leftmost octet in
         *    maskedDB are not all equal to zero, output "inconsistent" and stop. */
        bytes2 mask2 = (bytes2(0xFF00) >> (8 * emLen - nBits + 1)) & 0x00FF;
        bytes1 mask = bytes1(mask2[1]);
        // bytes1 mask = bytes2(0xFF00 >> (8 * emLen - rsaBits)) & 0xFF;
        if ((digest[emStart] & mask) != 0) {
            // return 3;
        }
        uint256 maskLen = emLen - SHA1SIZE - 1;
        bytes memory h = new bytes(SHA1SIZE);
        for (uint256 i = 0; i < SHA1SIZE; i++) {
            h[i] = digest[emStart + maskLen + i];
        }
        /* 7. Let dbMask = MGF(H, emLen - hLen - 1). */
        // bytes memory dbMask = pss_mgf1(h, maskLen);
        if (false == pss_verifyMask(h, insecureMask, maskLen)) {
            return 7;
        }
        /* 8. Let DB = maskedDB \xor dbMask. */
        bytes memory DB = xorBytes(digest, insecureMask, emStart, maskLen);
        /* 9. Set the leftmost 8emLen - emBits bits of the leftmost octet
         * in DB to zero. */
        DB[0] = DB[0] & ~mask;
        // /* 10. If the emLen - hLen - sLen - 2 leftmost octets of DB are not zero
        //  * or if the octet at position emLen - hLen - sLen - 1 (the leftmost
        //  * position is "position 1") does not have hexadecimal value 0x01,
        //  * output "inconsistent" and stop. */
        uint256 checkLen = emLen - SHA1SIZE - 20 - 2;
        if (DB[checkLen] != 0x01) {
            // return 4;
        }
        for (uint256 i = 0; i < checkLen; i++) {
            if (DB[i] != 0x00) {
                // return 5;
            }
        }
        // /* 11. Let salt be the last sLen octets of DB. */
        bytes memory salt = new bytes(20);
        for (uint256 i = 0; i < 20; i++) salt[i] = DB[DB.length - 20 + i];
        // /* 12.  Let M' = (0x)00 00 00 00 00 00 00 00 || mHash || salt */
        bytes memory m = abi.encodePacked(
            bytes8(0),
            bytes20(passportHash),
            salt
        );
        // /* 13. Let H' = Hash(M'), an octet string of length hLen. */
        bytes20 h_ = SHA1.sha1(m);
        // /* 14. If H = H', output "consistent." Otherwise, output "inconsistent." */
        for (uint256 i = 0; i < 20; i++) {
            if (h[i] != h_[i]) {
                // return 6;
            }
        }
        // return 0;
    }

    function pss_verifyMask(
        bytes memory seed,
        bytes memory mask,
        uint256 byteLength
    ) public view returns (bool) {
        uint256 blocks = byteLength / SHA1SIZE;
        uint256 extraBytes = byteLength % SHA1SIZE;
        if (extraBytes > 0) blocks += 1;
        else extraBytes = 20;

        bytes4 c = bytes4(0);
        bytes20 first = SHA1.sha1(abi.encodePacked(seed, bytes4(0)));
        bytes20 last = SHA1.sha1(
            abi.encodePacked(seed, bytes4(uint32(blocks) - 1))
        );
        for (uint256 i = 0; i < SHA1SIZE; i++) {
            if (first[i] != mask[i]) return false;
        }
        for (uint256 i = 0; i < extraBytes; i++) {
            if (last[i] != mask[mask.length - extraBytes + i]) return false;
        }
        return true;
    }

    function pss_mgf1(bytes memory seed, uint256 byteLength)
        public
        view
        returns (bytes memory)
    {
        uint256 blocks = byteLength / SHA1SIZE;
        if (byteLength % SHA1SIZE > 0) blocks += 1;
        bytes memory result;
        for (uint32 i = 0; i < blocks; i++) {
            /* a. Convert counter to an octet string C of length 4 octets */
            bytes4 c = bytes4(i);
            result = abi.encodePacked(
                result,
                SHA1.sha1(abi.encodePacked(seed, c))
            );
        }

        return result;
    }

    function xorBytes(
        bytes memory a,
        bytes memory b,
        uint256 start,
        uint256 length
    ) public view returns (bytes memory) {
        bytes memory res = new bytes(length);
        for (uint256 i = 0; i < length; i++) {
            res[i] = a[start + i] ^ b[i];
        }
        return res;
    }

    function verifyPKCS(bytes memory digest, bytes32 passportHash)
        public
        view
        returns (bool)
    {
        uint256 i;
        uint256 paddingLen = digest.length - 3 - SHA256PREFIX.length - 32;

        if (digest[0] != 0 || digest[1] != 0x01) {
            return false;
        }
        for (i = 2; i < 2 + paddingLen; i++) {
            if (digest[i] != 0xff) {
                return false;
            }
        }
        if (digest[2 + paddingLen] != 0) {
            return false;
        }
        for (i = 0; i < SHA256PREFIX.length; i++) {
            if (uint8(digest[3 + paddingLen + i]) != SHA256PREFIX[i]) {
                return false;
            }
        }
        for (i = 0; i < passportHash.length; i++) {
            if (
                digest[3 + paddingLen + SHA256PREFIX.length + i] !=
                passportHash[i]
            ) {
                return false;
            }
        }
        return true;
    }

    function verifyProof(
        bytes memory n,
        bytes memory e,
        uint256[] memory ds,
        bytes[] memory ts,
        bytes memory inverse_digest,
        bytes32[] memory unique,
        bytes32 randomOracleHash
    ) public view returns (bytes memory, bytes32) {
        bytes[] memory Ts = new bytes[](8);
        for (uint256 i = 0; i < 8; i++) {
            bytes memory T = verifyStep(n, e, ds[i], ts[i], inverse_digest);
            Ts[i] = T;
        }
        return verifyHash(Ts, unique, randomOracleHash);
    }

    /**
    @dev is public key in list of authorized passports signers
    TODO: check registery of public keys
     */
    function isKnownSigner(bytes memory n, bytes memory e)
        public
        view
        returns (bool)
    {
        return true;
    }

    /**
    @dev is passporthash not already used
    TODO: check registery of identities
     */
    function isIdentityNew(bytes32 identity) public view returns (bool) {
        return true;
    }

    function saveIdentity(uint256 identityHash, address owner) internal {}

    /**
    @dev verify request is by the holder of the public key
    */
    function verifySigner(
        bytes memory signedRequest,
        bytes32 msgHash,
        address requester
    ) internal view returns (bool) {
        return false;
    }

    function verifyHash(
        bytes[] memory Ts,
        bytes32[] memory unique,
        bytes32 randomOracleHash
    ) public view returns (bytes memory, bytes32) {
        bytes memory toHash = abi.encodePacked(
            Ts[0],
            Ts[1],
            Ts[2],
            Ts[3],
            Ts[4],
            Ts[5],
            Ts[6],
            Ts[7],
            unique[0], //passportHash
            unique[1], //publicKey
            unique[2] //nonce
        );
        bytes32 proof = sha256(toHash);
        // require(
        //     randomOracleHash == proof,
        //     "proof not equal to randomOracleHash"
        // );
        return (toHash, proof);
    }

    /*
v = await GQVerifier.new();
v.verifyInverseM("0x01FFFFFFFFFFFFFFFFFFFF003031300D060960864801650304020105000420869C20A7D0ADB3234B2CF62C536BA40FD2EF76DD486AEB0DF6BD36C336487A40","0xA6F3EDB9C6CE459CA339B41F41CD04CBBA2277F2C019E018AA7CC2F35B702584D9F6C7EEA110E8E0A082010868E58EA87E7831659583D1D53C310A0AF7685453","0x1a1e27420ec1a565806982e0dd4679d005b042b0bf93aa9a7f1c766bc285434db04a091426954819c7e80c66d31495ef3d86b1f470b3f3b0ae195ce7f8608992")
 */
    function verifyInverseM(
        bytes memory digest,
        bytes memory n,
        bytes memory inverse_digest
    ) public view returns (bytes memory) {
        BigNumber.instance memory bn_m = BigNumber.instance(
            digest,
            false,
            digest.length * 8
        ); //rsa digest 2048

        BigNumber.instance memory bn_inversem = BigNumber.instance(
            inverse_digest,
            false,
            512
        );
        BigNumber.instance memory bn_n = BigNumber.instance(
            n,
            false,
            n.length * 8
        );

        // this verifies inverse_m = m.invmod(n), other wise it reverts
        bn_m.mod_inverse(bn_n, bn_inversem);
        return bn_inversem.val;
    }

    function verifyStep(
        bytes memory n,
        bytes memory e,
        uint256 d,
        bytes memory t1,
        bytes memory m
    ) public view returns (bytes memory) {
        BigNumber.instance memory bn_3 = BigNumber.instance("0x3", false, 8);

        bytes memory b_d = new bytes(32);
        assembly {
            mstore(add(b_d, 32), d)
        }

        BigNumber.instance memory bn_e = BigNumber.instance(e, false, 32);
        BigNumber.instance memory bn_d = BigNumber.instance(b_d, false, 32);
        BigNumber.instance memory bn_n = BigNumber.instance(
            n,
            false,
            n.length * 8
        );
        BigNumber.instance memory bn_t1 = BigNumber.instance(t1, false, 512);
        BigNumber.instance memory bn_m = BigNumber.instance(m, false, 512);

        require(bn_d.cmp(bn_3, false) > -1, "d must be >2");

        BigNumber.instance memory te1 = bn_t1.prepare_modexp(bn_e, bn_n);
        BigNumber.instance memory md1 = bn_m.prepare_modexp(bn_d, bn_n);

        BigNumber.instance memory T1 = te1.modmul(md1, bn_n);

        // emit BN("te", te1.val, te1.neg, te1.bitlen);
        // emit BN("d", bn_d.val, bn_d.neg, bn_d.bitlen);
        // emit BN("md", md1.val, md1.neg, md1.bitlen);
        // emit BN("T", T1.val, T1.neg, T1.bitlen);

        return T1.val;
    }
}
